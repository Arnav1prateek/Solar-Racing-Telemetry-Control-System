import threading 
import time
import folium
import subprocess
import socket
import queue
import RPi.GPIO as GPIO
import os

# ? GPIO Setup
GPIO.setmode(GPIO.BCM)
BUTTON_REAR_PARK = 17
BUTTON_FRONT_PARK = 27  # UI + Server
BUTTON_OBJECT_DETECTION = 22
BUZZER = 24  
GPIO.setup(BUTTON_REAR_PARK, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(BUTTON_FRONT_PARK, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(BUTTON_OBJECT_DETECTION, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(BUZZER, GPIO.OUT, initial=GPIO.LOW)

# ? Global variables for subprocesses
rear_process = None
object_process = None
server_process = None
ui_process = None

# ? GPS Configuration
gps_queue = queue.Queue()
UDP_PORT = 5005

# ? NMEA Parsing Function
def parse_nmea(nmea_sentence):
    """Parses NMEA GPGGA sentence and returns latitude and longitude in decimal degrees."""
    try:
        parts = nmea_sentence.split(',')

        if parts[0] != "$GPGGA" or len(parts) < 10:
            print("? Invalid NMEA sentence.")
            return None, None

        lat_raw, lat_dir = parts[2], parts[3]
        lon_raw, lon_dir = parts[4], parts[5]

        if not lat_raw or not lon_raw:
            print("? Missing lat/lon data.")
            return None, None

        # ? Convert to decimal degrees
        lat = float(lat_raw[:2]) + float(lat_raw[2:]) / 60
        if lat_dir == 'S':
            lat = -lat

        lon = float(lon_raw[:3]) + float(lon_raw[3:]) / 60
        if lon_dir == 'W':
            lon = -lon

        return round(lat, 6), round(lon, 6)

    except Exception as e:
        print(f"? NMEA Parsing Error: {e}")
        return None, None

# ? GPS Listener
def gps_listener():
    """Listens for GPS data, parses NMEA sentences, and pushes coordinates into the queue."""
    print("Starting GPS listener...")

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.bind(("", UDP_PORT))
        print(f"Listening for GPS data on port {UDP_PORT}...")

        while True:
            try:
                data, _ = sock.recvfrom(1024)
                nmea_sentence = data.decode().strip()

                if nmea_sentence.startswith("$GPGGA"):
                    lat, lon = parse_nmea(nmea_sentence)
                    
                    if lat is not None and lon is not None:
                        gps_queue.put((lat, lon))
                        print(f"? GPS Updated: {lat}, {lon}")
                    else:
                        print("?? No valid coordinates extracted.")
                else:
                    print(f"?? Ignored: {nmea_sentence}")

            except Exception as e:
                print(f"? GPS Listener Error: {e}")

    except Exception as e:
        print(f"? Failed to start GPS listener: {e}")
# ? Map Generator
def generate_map():
    """Generates and refreshes the map using real-time GPS data."""
    
    # Open the map once
    if not hasattr(generate_map, 'browser_opened'):
        map_path = "/home/asus/car_map.html"
        subprocess.Popen(
            ["chromium-browser", "--kiosk", "--disable-infobars", "--noerrdialogs", "--start-fullscreen", map_path],
            stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
        )
        generate_map.browser_opened = True

    # Initialize with default coordinates (Delhi)
    lat, lon = 28.6139, 77.2090  

    while True:
        try:
            # Get latest GPS coordinates from the queue
            if not gps_queue.empty():
                lat, lon = gps_queue.get_nowait()

            # Generate the map with the latest GPS coordinates
            car_map = folium.Map(location=[lat, lon], zoom_start=18)
            folium.Marker(
                [lat, lon],
                popup=f"Car Location: {lat:.6f}, {lon:.6f}",
                icon=folium.Icon(color="red")
            ).add_to(car_map)

            # Save the map with auto-refresh
            map_path = "/home/asus/car_map.html"
            with open(map_path, "w") as f:
                f.write(f"""
                <html>
                <head>
                    <script>
                    function refreshMap() {{
                        setTimeout(() => {{
                            window.location.reload();
                        }}, 3000);
                    }}
                    </script>
                </head>
                <body onload="refreshMap()">
                {car_map.get_root().render()}
                </body>
                </html>
                """)

            print(f"? Map updated at: {lat}, {lon}")

        except Exception as e:
            print(f"? Error generating map: {e}")

        time.sleep(3)

# ? Beep Function for Buzzer
def beep_buzzer():
    """Activates the buzzer for a short beep."""
    GPIO.output(BUZZER, GPIO.HIGH)
    time.sleep(0.1)
    GPIO.output(BUZZER, GPIO.LOW)

# ? Improved Script Execution Function
def execute_script(command, process_var, use_shell=False):
    """Executes or terminates a script based on the process state."""
    if process_var:
        process_var.terminate()
        return None
    else:
        if use_shell:
            process = subprocess.Popen(command, shell=True, executable="/bin/bash")
        else:
            process = subprocess.Popen(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return process

# ? Button Listener with Toggle for All
def button_listener():
    """Listens for button presses and handles parking assist, UI, server, and object detection."""
    global rear_process, object_process, server_process, ui_process
    rear_state = GPIO.HIGH
    front_state = GPIO.HIGH
    object_state = GPIO.HIGH

    while True:
        # Rear Parking Toggle
        if GPIO.input(BUTTON_REAR_PARK) == GPIO.LOW and rear_state == GPIO.HIGH:
            beep_buzzer()
            if rear_process:
                print("Stopping Rear Parking...")
                rear_process.terminate()
                rear_process = None
            else:
                print("Starting Rear Parking...")
                rear_process = subprocess.Popen(["python3", "/home/asus/system/rear_parking.py"])
            rear_state = GPIO.LOW
        elif GPIO.input(BUTTON_REAR_PARK) == GPIO.HIGH:
            rear_state = GPIO.HIGH

        # Server + UI Toggle
        if GPIO.input(BUTTON_FRONT_PARK) == GPIO.LOW and front_state == GPIO.HIGH:
            beep_buzzer()

            if server_process or ui_process:
                print("Stopping Server and UI...")
                if server_process:
                    server_process.terminate()
                    server_process = None
                if ui_process:
                    ui_process.terminate()
                    ui_process = None
                
                print("Relaunching the map...")
                map_path = "/home/asus/car_map.html"
                subprocess.Popen(
                    ["chromium-browser", "--kiosk", "--disable-infobars", "--noerrdialogs", "--start-fullscreen", map_path],
                    stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                )
            else:
                print("Starting Server and UI...")
                server_process = subprocess.Popen(["/usr/bin/python3", "/home/asus/system/server/server.py"])
                ui_command = "source /home/asus/venv/bin/activate && streamlit run /home/asus/system/ui/ui.py"
                ui_process = subprocess.Popen(ui_command, shell=True, executable="/bin/bash")
            
            front_state = GPIO.LOW
        elif GPIO.input(BUTTON_FRONT_PARK) == GPIO.HIGH:
            front_state = GPIO.HIGH

        # Object Detection Toggle
        if GPIO.input(BUTTON_OBJECT_DETECTION) == GPIO.LOW and object_state == GPIO.HIGH:
            beep_buzzer()
            if object_process:
                print("Stopping Object Detection...")
                object_process.terminate()
                object_process = None
            else:
                print("Starting Object Detection...")
                object_process = subprocess.Popen(["python3", "/home/asus/system/object_detection/object_detection.py"])
            object_state = GPIO.LOW
        elif GPIO.input(BUTTON_OBJECT_DETECTION) == GPIO.HIGH:
            object_state = GPIO.HIGH

        time.sleep(0.2)

# ? Start Threads
threading.Thread(target=gps_listener).start()
threading.Thread(target=generate_map, daemon=True).start()
threading.Thread(target=button_listener, daemon=True).start()

try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    GPIO.cleanup()
